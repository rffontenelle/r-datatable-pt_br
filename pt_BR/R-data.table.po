# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Leonardo Fontenelle, 2024
# 
msgid ""
msgstr ""
"Project-Id-Version: data.table 0.0\n"
"POT-Creation-Date: 2024-02-15 21:23-0300\n"
"PO-Revision-Date: 2024-04-10 02:58+0000\n"
"Last-Translator: Leonardo Fontenelle, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/rafaelff1/teams/190680/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % 1000000 == 0 ? 1 : 2;\n"

#: data.table.R:63
msgid "key argument of data.table() must be character"
msgstr "o argumento key do data.table() deve ser caractere"

#: data.table.R:132
msgid "Object '%s' not found. Perhaps you intended %s"
msgstr "Objeto '%s' não encontrado. Talvez sua intenção fosse %s"

#: data.table.R:134
msgid "Object '%s' not found amongst %s"
msgstr "Objeto '%s' não encontrado entre %s"

#: data.table.R:157
msgid "verbose must be logical or integer"
msgstr "verbose deve ser lógico ou inteiro"

#: data.table.R:158
msgid "verbose must be length 1 non-NA"
msgstr "verbose deve ser não NA e de comprimento 1"

#: data.table.R:166
msgid "Ignoring by/keyby because 'j' is not supplied"
msgstr "Ignorando by/keyby porque 'j' não foi fornecido"

#: data.table.R:180
msgid "When by and keyby are both provided, keyby must be TRUE or FALSE"
msgstr "Quando by e keyby são ambos fornecidos, keyby deve ser TRUE ou FALSE"

#: data.table.R:183 data.table.R:247 data.table.R:335
msgid "Argument '%s' after substitute: %s"
msgstr "Argumento '%s' após substituto: %s"

#: data.table.R:192
msgid ""
"When on= is provided but not i=, on= must be a named list or "
"data.table|frame, and a natural join (i.e. join on common names) is invoked."
" Ignoring on= which is '%s'."
msgstr ""
"Quando on= é fornecido, mas não i=, on= deve ser uma lista nomeada ou "
"data.table|frame, e uma junção natural (ou seja, junção em nomes comuns) é "
"invocada. Ignorando on= , que é '%s'."

#: data.table.R:205
msgid ""
"i and j are both missing so ignoring the other arguments. This warning will "
"be upgraded to error in future."
msgstr ""
"i e j estão faltando, ignorando os outros argumentos. Este aviso será "
"atualizado para se tornar um erro no futuro."

#: data.table.R:209
msgid "mult argument can only be 'first', 'last' or 'all'"
msgstr "o argumento mult só pode ser 'first', 'last' ou 'all'"

#: data.table.R:211
msgid ""
"roll must be a single TRUE, FALSE, positive/negative integer/double "
"including +Inf and -Inf or 'nearest'"
msgstr ""
"roll deve ser TRUE, FALSE, número inteiro/duplo positivo/negativo, incluindo"
" +Inf e -Inf ou 'nearest'"

#: data.table.R:213
msgid ""
"roll is '%s' (type character). Only valid character value is 'nearest'."
msgstr ""
"roll é '%s' (tipo caractere). O único valor de caractere válido é 'nearest'."

#: data.table.R:218
msgid "rollends must be a logical vector"
msgstr "rollends deve ser um vetor lógico"

#: data.table.R:219
msgid "rollends must be length 1 or 2"
msgstr "rollends deve ter comprimento 1 ou 2"

#: data.table.R:227
msgid ""
"nomatch= must be either NA or NULL (or 0 for backwards compatibility which "
"is the same as NULL but please use NULL)"
msgstr ""
"nomatch= deve ser NA ou NULL (ou 0 para compatibilidade com versões "
"anteriores, que é igual a NULL, mas use NULL)"

#: data.table.R:230
msgid "which= must be a logical vector length 1. Either FALSE, TRUE or NA."
msgstr "which= deve ser um vetor lógico de comprimento 1. FALSE, TRUE ou NA."

#: data.table.R:231
msgid ""
"which==%s (meaning return row numbers) but j is also supplied. Either you "
"need row numbers or the result of j, but only one type of result can be "
"returned."
msgstr ""
"which==%s (significando retornar números de linha), mas j também é "
"fornecido. Ou você precisa de números de linha ou do resultado de j, mas "
"apenas um tipo de resultado pode ser retornado."

#: data.table.R:232
msgid ""
"which=NA with nomatch=0|NULL would always return an empty vector. Please "
"change or remove either which or nomatch."
msgstr ""
"which=NA com nomatch=0|NULL sempre retornaria um vetor vazio. Favor alterar "
"ou remover ou which, ou nomatch."

#: data.table.R:233
msgid "j must be provided when with=FALSE"
msgstr "j deve ser fornecido quando with=FALSE"

#: data.table.R:273
msgid ""
"The symbol .. is invalid. The .. prefix must be followed by at least one "
"character."
msgstr ""
"O símbolo .. é inválido. O prefixo .. deve ser seguido por pelo menos um "
"caractere."

#: data.table.R:276
#, c-format
msgid ""
"Variable '..%s' does exist in calling scope though, so please just removed "
"the .. prefix from that variable name in calling scope."
msgstr ""
"A variável '..%s' existe no escopo de chamada, portanto, então favor "
"simplesmente remover o prefixo .. desse nome de variável no escopo de "
"chamada."

#: data.table.R:280
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you used the .. prefix.%s"
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque você usou .. como prefixo.%s"

#: data.table.R:282
msgid ""
"Both '%1$s' and '..%1$s' exist in calling scope. Please remove the '..%1$s' "
"variable in calling scope for clarity."
msgstr ""
"Tanto '%1$s' quanto '..%1$s' existem no escopo de chamada. Remova a variável"
" '..%1$s' na chamada do escopo para maior clareza."

#: data.table.R:288
msgid ""
"Internal error:  DT[, ..var] should be dealt with by the branch above now."
msgstr ""
"Erro interno: agora o branch acima deveria ter lidado com DT[, ..var]."

#: data.table.R:290
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because you set with=FALSE. Also, please use .. symbol prefix and remove "
"with=FALSE."
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque você definiu with=FALSE. Além disso, favor usr o "
"prefixo de símbolo .. e remover with=FALSE."

#: data.table.R:298
msgid ""
"You have wrapped := with {} which is ok but then := must be the only thing "
"inside {}. You have something else inside {} as well. Consider placing the "
"{} on the RHS of := instead; e.g. "
"DT[,someCol:={tmpVar1<-...;tmpVar2<-...;tmpVar1*tmpVar2}"
msgstr ""
"Você envolveu := com {}, o que está tudo bem, mas := deve ser a única coisa "
"dentro de {}. Você também tem algo mais dentro de {}. Considere colocar {} "
"ao lado direito de :=; por exemplo, "
"DT[,algumaCol:={tmpVar1<-...;tmpVar2<-...;tmpVar1*tmpVar2}]"

#: data.table.R:318
msgid ""
":= with keyby is only possible when i is not supplied since you can't setkey"
" on a subset of rows. Either change keyby to by or remove i"
msgstr ""
":= com keyby só é possível quando i não é fornecido, pois você não pode "
"definir a chave em um subconjunto de linhas. Ou altere keyby para by, ou "
"remova i"

#: data.table.R:320
msgid "nomatch isn't relevant together with :=, ignoring nomatch"
msgstr "nomatch não é relevante junto com :=, ignorando nomatch"

#: data.table.R:376
msgid ""
"not-join '!' prefix is present on i but nomatch is provided. Please remove "
"nomatch."
msgstr ""
"prefixo '!', não de junção, está presente em i, mas nomatch foi fornecido. "
"Por favor, remova nomatch."

#: data.table.R:405
msgid ""
"Operator := detected in i, the first argument inside DT[...], but is only "
"valid in the second argument, j. Most often, this happens when forgetting "
"the first comma (e.g. DT[newvar := 5] instead of DT[ , new_var := 5]). "
"Please double-check the syntax. Run traceback(), and debugger() to get a "
"line number."
msgstr ""
"Operador := detectado em i, o primeiro argumento dentro de DT[...], mas só é"
" válido no segundo argumento, j. Na maioria das vezes, isso acontece quando "
"se esquece a primeira vírgula (por exemplo, DT[nova_var := 5] em vez de DT[ "
", nova_var := 5]). Verifique novamente a sintaxe. Execute traceback() e "
"debugger() para obter um número de linha."

#: data.table.R:416
#, c-format
msgid "'%s' is not found in calling scope and it is not a column name either"
msgstr ""
"'%s' não foi encontrado no escopo de chamada e também não é um nome de "
"coluna"

#: data.table.R:419
#, c-format
msgid ""
"'%s' is not found in calling scope, but it is a column of type %s. If you "
"wish to select rows where that column contains TRUE, or perhaps that column "
"contains row numbers of itself to select, try DT[(col)], DT[DT$col], or "
"DT[col==TRUE} is particularly clear and is optimized"
msgstr ""
"'%s' não foi encontrado no escopo de chamada, mas é uma coluna do tipo %s. "
"Se você deseja selecionar linhas onde essa coluna contém TRUE, ou talvez "
"onde essa coluna contenha números de linha para selecionar, tente DT[(col)],"
" DT[DT$col] ou DT[col==TRUE}, o que é particularmente claro e otimizado"

#: data.table.R:422
msgid ""
"%s. When the first argument inside DT[...] is a single symbol (e.g. "
"DT[var]), data.table looks for var in calling scope."
msgstr ""
"%s. Quando o primeiro argumento dentro de DT[...] é um único símbolo (por "
"exemplo, DT[var]), data.table procura por var na chamada do escopo."

#: data.table.R:434
msgid ""
"i is invalid type (matrix). Perhaps in future a 2 column matrix could return"
" a list of elements of DT (in the spirit of A[B] in FAQ 2.14). Please report"
" to data.table issue tracker if you'd like this, or add your comments to FR "
"#657."
msgstr ""
"i é um tipo inválido (matrix). Talvez no futuro uma matriz de 2 colunas "
"possa retornar uma lista de elementos de DT (no espírito de A[B] no FAQ "
"2.14). Por favor, relate no rastreador de problemas do data.table se desejar"
" isso, ou adicione seus comentários ao FR #657."

#: data.table.R:457
msgid ""
"When i is a data.table (or character vector), the columns to join by must be"
" specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted,"
" and, marked as sorted, see ?setkey), or by sharing column names between x "
"and i (i.e., a natural join). Keyed joins might have further speed benefits "
"on very large data due to x being sorted in RAM."
msgstr ""
"Quando i é uma data.table (ou vetor de caracteres), as colunas nas quais "
"fazer a junção devem ser especificadas usando o argumento 'on=' (consulte "
"?data.table), por meio de chaveamento de x (ou seja, ordenado e marcado como"
" ordenado, consulte ?setkey) ou compartilhando de nomes de colunas entre x e"
" i (ou seja, uma junção natural). As junções chaveadas podem ter benefícios "
"adicionais de velocidade em dados muito grandes devido ao x estar ordenado "
"na RAM."

#: data.table.R:465
msgid "Attempting to do natural join but no common columns in provided tables"
msgstr ""
"Tentando fazer junção natural, mas não há colunas comuns nas tabelas "
"fornecidas"

#: data.table.R:468
msgid "Joining but 'x' has no key, natural join using all 'x' columns"
msgstr ""
"Junção sendo que 'x' não tem chave, então fazendo junção natural usando "
"todas as colunas de 'x'"

#: data.table.R:470
msgid "Joining but 'x' has no key, natural join using: %s"
msgstr ""
"Junção sendo que 'x' não tem chave, então fazendo junção natural usando: %s"

#: data.table.R:499
msgid ""
"not-join called with 'by=.EACHI'; Replacing !i with i=setdiff_(x,i) ..."
msgstr ""
"not-join chamado com 'by=.EACHI'; substituindo !i por i=setdiff_(x,i) ..."

#: data.table.R:502
msgid "done in %s"
msgstr "concluído em %s"

#: data.table.R:529
msgid "Constructing irows for '!byjoin || nqbyjoin' ..."
msgstr "Construindo irows para '!byjoin || nqbyjoin' ..."

#: data.table.R:543
msgid "Internal error. Cannot by=.EACHI when joining to an index, yet"
msgstr ""
"Erro interno. Ainda não é possível usar by=.EACHI ao fazer junção em um "
"índice"

#: data.table.R:546
msgid "Internal error. irows has length in by=.EACHI"
msgstr "Erro interno. irows tem comprimento em by=.EACHI"

#: data.table.R:568
msgid "Reorder irows for 'mult==\"all\" && !allGrp1' ..."
msgstr "Reordenar irows para 'mult==\"all\" && !allGrp1' ..."

#: data.table.R:580
msgid "Reordering %d rows after bmerge done in ..."
msgstr "Reordenando %d linhas após bmerge feito em ..."

#: data.table.R:597
msgid "logical error. i is not a data.table, but 'on' argument is provided."
msgstr ""
"erro lógico. i não é uma data.table, mas o argumento 'on' foi fornecido."

#: data.table.R:601
msgid "i has evaluated to type %s. Expecting logical, integer or double."
msgstr "i é avaliado para o tipo %s. Esperava lógico, inteiro ou 'double'."

#: data.table.R:605
msgid ""
"internal error: notjoin and which=NA (non-matches), huh? please provide "
"reproducible example to issue tracker"
msgstr ""
"erro interno: notjoin e which=NA (não correspondências). Mas hein? Por "
"favor, forneça um exemplo reproduzível no rastreador de problemas"

#: data.table.R:623
msgid ""
"i evaluates to a logical vector length %d but there are %d rows. Recycling "
"of logical i is no longer allowed as it hides more bugs than is worth the "
"rare convenience. Explicitly use rep(...,length=.N) if you really need to "
"recycle."
msgstr ""
"i é avaliado como um vetor lógico de comprimento %d, mas há %d linhas. A "
"reciclagem do i lógico não é mais permitida, pois mais esconde bugs do que "
"vale a rara conveniência. Use explicitamente rep(...,length=.N) se você "
"realmente precisar reciclar."

#: data.table.R:639
msgid "Internal error: notjoin but byjoin or !integer or nomatch==NA"
msgstr "Erro interno: notjoin, mas byjoin ou !integer ou nomatch==NA"

#: data.table.R:641
msgid "Inverting irows for notjoin done in ..."
msgstr "Inversão de irows por notjoin feita em ..."

#: data.table.R:699
msgid ""
"with=FALSE together with := was deprecated in v1.9.4 released Oct 2014. "
"Please wrap the LHS of := with parentheses; e.g., DT[,(myVar):=sum(b),by=a] "
"to assign to column name(s) held in variable myVar. See ?':=' for other "
"examples. As warned in 2014, this is now a warning."
msgstr ""
"o uso de with=FALSE junto com := foi descontinuado em v1.9.4, lançado em "
"outubro de 2014. Coloque o LHS de := entre parênteses; por exemplo, "
"DT[,(myVar):=sum(b),by=a] para atribuir nomes de colunas mantidos na "
"variável myVar. Veja ?':=' para outros exemplos.  Tal como avisado em 2014, "
"isto é agora um aviso."

#: data.table.R:702
msgid ""
"with=FALSE ignored, it isn't needed when using :=. See ?':=' for examples."
msgstr ""
"with=FALSE ignorado, não é necessário ao usar :=. Veja ?':=' para exemplos."

#: data.table.R:726
msgid "column(s) not removed because not found: %s"
msgstr "coluna(s) não removida(s) por não ter(em) sido encontrada(s): %s"

#: data.table.R:740
msgid "column(s) not found: %s"
msgstr "coluna(s) não encontrada(s): %s"

#: data.table.R:746
msgid ""
"Item %d of j is %d which is outside the column number range [1,ncol=%d]"
msgstr ""
"O item %d de j é %d, o qual está fora do intervalo de números de colunas "
"[1,ncol=%d]"

#: data.table.R:749
msgid "j mixes positives and negatives"
msgstr "j mistura positivos e negativos"

#: data.table.R:757
msgid ""
"When with=FALSE, j-argument should be of type logical/character/integer "
"indicating the columns to select."
msgstr ""
"Quando with=FALSE, o argumento j deve ser do tipo lógico/caractere/inteiro "
"indicando as colunas a serem selecionadas."

#: data.table.R:771
msgid ""
"'by' contains .I but only the following are currently supported: by=.I, "
"by=.(.I), by=c(.I), by=list(.I)"
msgstr ""
"'by' contém .I, mas apenas o seguinte é suportado atualmente: by=.I, "
"by=.(.I), by=c(.I), by=list(.I)"

#: data.table.R:795
msgid "by=c(...), key(...) or names(...) must evaluate to 'character'"
msgstr ""
"by=c(...), key(...) ou names(...) devem ser avaliados para 'character'"

#: data.table.R:805
msgid ""
"'by' is a character vector length %d but one or more items include a comma. "
"Either pass a vector of column names (which can contain spaces, but no "
"commas), or pass a vector length 1 containing comma separated column names. "
"See ?data.table for other possibilities."
msgstr ""
"'by' é um vetor de caracteres de comprimento %d, mas um ou mais itens "
"incluem uma vírgula. Passe um vetor de nomes de colunas (que pode conter "
"espaços, mas sem vírgulas) ou passe um vetor de comprimento 1 contendo nomes"
" de colunas separados por vírgulas. Consulte ?data.table para outras "
"possibilidades."

#: data.table.R:839
msgid "by index '%s' but that index has 0 length. Ignoring."
msgstr "pelo índice '%s', mas esse índice tem comprimento 0. Ignorando."

#: data.table.R:853
msgid "Internal error: irows isn't integer"
msgstr "Erro interno: irows não é inteiro"

#: data.table.R:862
msgid ""
"i clause present and columns used in by detected, only these subset: %s"
msgstr ""
"cláusula i presente e colunas usadas em by detectadas, apenas esses "
"subconjuntos: %s"

#: data.table.R:865
msgid ""
"i clause present but columns used in by not detected. Having to subset all "
"columns before evaluating 'by': '%s'"
msgstr ""
"cláusula i presente, mas colunas usadas em by não detectadas. Necessário "
"dividir em subconjuntos todas as colunas antes de avaliar 'by': '%s'"

#: data.table.R:887
msgid ""
"'by' appears to evaluate to column names but isn't c() or key(). Use "
"by=list(...) if you can. Otherwise, by=eval%s should work. This is for "
"efficiency so data.table can detect which columns are needed."
msgstr ""
"'by' parece avaliar nomes de colunas, mas não é c() ou key(). Use "
"by=list(...) se puder. Caso contrário, by=eval%s deve funcionar. Isso é para"
" maior eficiência, para que data.table possa detectar quais colunas são "
"necessárias."

#: data.table.R:898
msgid ""
"'by' or 'keyby' must evaluate to a vector or a list of vectors (where 'list'"
" includes data.table and data.frame which are lists, too)"
msgstr ""
"'by' ou 'keyby' deve ser avaliado como um vetor ou uma lista de vetores "
"(onde 'list' inclui data.table e data.frame que também são listas)"

#: data.table.R:902
msgid ""
"Column or expression %d of 'by' or 'keyby' is type '%s' which is not "
"currently supported. If you have a compelling use case, please add it to "
"https://github.com/Rdatatable/data.table/issues/1597. As a workaround, "
"consider converting the column to a supported type, e.g. by=sapply(list_col,"
" toString), whilst taking care to maintain distinctness in the process."
msgstr ""
"A coluna ou expressão %d de 'by' ou 'keyby' é do tipo '%s' e não é suportada"
" atualmente. Se você tiver um caso de uso atraente, adicione-o a "
"https://github.com/Rdatatable/data.table/issues/1597. Como solução "
"alternativa, considere converter a coluna em um tipo compatível, por "
"exemplo. by=sapply(list_col, toString), tomando cuidado para manter a "
"distinção no processo."

#: data.table.R:906
msgid ""
"The items in the 'by' or 'keyby' list are length(s) %s. Each must be length "
"%d; the same length as there are rows in x (after subsetting if i is "
"provided)."
msgstr ""
"Os itens na lista 'by' ou 'keyby' têm comprimento(s) %s. Cada um deve ter "
"comprimento %d; o mesmo comprimento que há linhas em x (após dividir em "
"subconjuntos se i for fornecido)."

#: data.table.R:925
msgid ""
"by-expression '%s' is not named, and the auto-generated name '%s' clashed "
"with variable(s) in j. Therefore assigning the entire by-expression as name."
msgstr ""
"a expressão by '%s' não é nomeada e o nome gerado automaticamente '%s' entra"
" em conflito com variáveis em j. Portanto, atribuindo toda a expressão by "
"como nome."

#: data.table.R:940
msgid "Internal error: drop_dot passed %d items"
msgstr "Erro interno: drop_dot passou %d itens"

#: data.table.R:959
msgid "Item %d of the .() or list() passed to j is missing"
msgstr "O item %d de .() ou list() passado para j está ausente"

#: data.table.R:965
msgid ""
"j may not evaluate to the same number of columns for each group; if you're "
"sure this warning is in error, please put the branching logic outside of [ "
"for efficiency"
msgstr ""
"j não pode ser avaliado com o mesmo número de colunas para cada grupo; se "
"você tiver certeza de que este aviso está errado, coloque a lógica de "
"branching fora de [ para eficiência"

#: data.table.R:967
msgid ""
"Different branches of j expression produced different auto-named columns: "
"%s; using the most \"last\" names. If this was intentional (e.g., you know "
"only one branch will ever be used in a given query because the branch is "
"controlled by a function argument), please (1) pull this branch out of the "
"call; (2) explicitly provide missing defaults for each branch in all cases; "
"or (3) use the same name for each branch and re-name it in a follow-up call."
msgstr ""
"Diferentes branches da expressão j produziram diferentes colunas nomeadas "
"automaticamente: %s; usando a maioria dos \"últimos\" nomes. Se isso foi "
"intencional (por exemplo, você sabe que apenas um branch será usado em uma "
"determinada consulta porque o branch é controlado por um argumento de "
"função). Por favor, (1) retire esse branch da chamada; (2) forneça "
"explicitamente os padrões ausentes para cada branch em todos os casos; ou "
"(3) use o mesmo nome para cada branch e renomeie-o em uma chamada seguinte."

#: data.table.R:1031
msgid ""
"When .SDcols is a function, it is applied to each column; the output of this"
" function must be a non-missing boolean scalar signalling "
"inclusion/exclusion of the column. However, these conditions were not met "
"for: %s"
msgstr ""
"Quando .SDcols é uma função, ela é aplicada a cada coluna; a saída desta "
"função deve ser um escalar booleano não ausente sinalizando "
"inclusão/exclusão da coluna. No entanto, estas condições não foram cumpridas"
" para: %s"

#: data.table.R:1037
msgid ".SDcols missing at the following indices: %s"
msgstr ".SDcols ausentes nos seguintes índices: %s"

#: data.table.R:1039
msgid ".SDcols is a logical vector length %d but there are %d columns"
msgstr ".SDcols tem um vetor lógico de comprimento %d, mas existem %d colunas"

#: data.table.R:1045
msgid ".SDcols is numeric but has both +ve and -ve indices"
msgstr ".SDcols é numérico, mas possui índices +ve e -ve"

#: data.table.R:1047
msgid ".SDcols is numeric but out of bounds [1, %d] at: %s"
msgstr ".SDcols é numérico, mas está fora dos limites [1, %d] em: %s"

#: data.table.R:1051
msgid ".SDcols should be column numbers or names"
msgstr ".SDcols devem ser números ou nomes de colunas"

#: data.table.R:1053
msgid "Some items of .SDcols are not column names: %s"
msgstr "Alguns itens de .SDcols não são nomes de colunas: %s"

#: data.table.R:1066
msgid ""
"'(m)get' found in j. ansvars being set to all columns. Use .SDcols or a single j=eval(macro) instead. Both will detect the columns used which is important for efficiency.\n"
"Old ansvars: %s"
msgstr ""
"'(m)get' encontrado em j. ansvars sendo definido para todas as colunas. Use .SDcols ou um único j=eval(macro) em vez disso. Ambos detectarão as colunas utilizadas, o que é importante para a eficiência.\n"
"ansvars antigo: %s"

#: data.table.R:1086
msgid "New ansvars: %s"
msgstr "Novo ansvars: %s"

#: data.table.R:1095
msgid ""
"This j doesn't use .SD but .SDcols has been supplied. Ignoring .SDcols. See "
"?data.table."
msgstr ""
"Este j não usa .SD, mas .SDcols foi fornecido. Ignorando .SDcols. Consulte "
"?data.table."

#: data.table.R:1098
msgid "Detected that j uses these columns: %s"
msgstr "Detectado que j usa estas colunas: %s"

#: data.table.R:1111
msgid ""
".SD is locked. Using := in .SD's j is reserved for possible future use; a "
"tortuously flexible way to modify by group. Use := in j directly to modify "
"by group by reference."
msgstr ""
".SD está travado. O uso de := em .SD j está reservado para possível uso "
"futuro; uma maneira tortuosamente flexível de modificar por grupo. Use := in"
" j diretamente para modificar por grupo por referência."

#: data.table.R:1119 data.table.R:1131
msgid "In %s(col1=val1, col2=val2, ...) form, all arguments must be named."
msgstr ""
"Na forma %s(col1=val1, col2=val2, ...), todos os argumentos devem ser "
"nomeados."

#: data.table.R:1136
msgid ""
"LHS of := must be a symbol, or an atomic vector (column names or positions)."
msgstr ""
"LHS de := deve ser um símbolo ou um vetor atômico (nomes de colunas ou "
"posições)."

#: data.table.R:1141
msgid ""
"LHS of := appears to be column positions but are outside [1,ncol] range. New"
" columns can only be added by name."
msgstr ""
"LHS de := parecem ser posições de coluna, mas estão fora do intervalo "
"[1,ncol]. Novas colunas só podem ser adicionadas por nome."

#: data.table.R:1144
msgid ""
"LHS of := isn't column names ('character') or positions ('integer' or "
"'numeric')"
msgstr ""
"LHS de := não são nomes de colunas ('character') ou posições ('integer' ou "
"'numeric')"

#: data.table.R:1160
msgid ""
"No rows match i. No new columns to add so not evaluating RHS of :=\n"
"Assigning to 0 row subset of %d rows"
msgstr ""
"Nenhuma linha corresponde a i. Não há novas colunas para adicionar, portanto não será avaliado RHS de :=\n"
"Atribuindo a 0 subconjunto de linhas com %d linhas"

#: data.table.R:1175
msgid ""
"Invalid .internal.selfref detected and fixed by taking a (shallow) copy of "
"the data.table so that := can add this new column by reference. At an "
"earlier point, this data.table has been copied by R (or was created manually"
" using structure() or similar). Avoid names<- and attr<- which in R "
"currently (and oddly) may copy the whole data.table. Use set* syntax instead"
" to avoid copying: ?set, ?setnames and ?setattr. If this message doesn't "
"help, please report your use case to the data.table issue tracker so the "
"root cause can be fixed or this message improved."
msgstr ""
".internal.selfref inválido detectado e corrigido fazendo uma cópia (rasa) do"
" data.table para que := possa adicionar esta nova coluna por referência. "
"Anteriormente, este data.table foi copiado por R (ou foi criado manualmente "
"usando structure() ou similar). Evite nomes<- e atributo<- que, atualmente "
"(e estranhamente) no R podem copiar todo o data.table. Use a sintaxe set* "
"para evitar copiar: ?set, ?setnames e ?setattr. Se esta mensagem não ajudar,"
" relate seu caso de uso ao rastreador de problemas data.table para que a "
"causa raiz possa ser corrigida ou esta mensagem melhorada."

#: data.table.R:1183
msgid ""
"Growing vector of column pointers from truelength %d to %d. A shallow copy "
"has been taken, see ?setalloccol. Only a potential issue if two variables "
"point to the same data (we can't yet detect that well) and if not you can "
"safely ignore this. To avoid this message you could setalloccol() first, "
"deep copy first using copy(), wrap with suppressWarnings() or increase the "
"'datatable.alloccol' option."
msgstr ""
"Vetor crescente de ponteiros de coluna de truelength %d para %d. Uma cópia "
"rasa foi obtida, consulte ?setalloccol. Apenas um problema potencial se duas"
" variáveis apontarem para os mesmos dados (ainda não podemos detectar isso "
"bem) e, do contrário, você pode ignorar isso com segurança. Para evitar esta"
" mensagem, você pode usar primeiro setalloccol(), fazer uma cópia profunda "
"primeiro usando copy(), cercar com suprimirWarnings() ou aumentar a opção "
"'datatable.alloccol'."

#: data.table.R:1185
msgid ""
"Note that the shallow copy will assign to the environment from which := was "
"called. That means for example that if := was called within a function, the "
"original table may be unaffected."
msgstr ""
"Observe que a cópia rasa será atribuída ao ambiente do qual := foi chamado. "
"Isso significa, por exemplo, que se := foi chamado dentro de uma função, a "
"tabela original pode não ser afetada."

#: data.table.R:1206
msgid ""
"Cannot assign to an under-allocated recursively indexed list -- L[[i]][,:=] "
"syntax is only valid when i is length 1, but its length is %d"
msgstr ""
"Não é possível atribuir a uma lista indexada recursivamente subalocada - a "
"sintaxe L[[i]][,:=] só é válida quando i tem comprimento 1, mas seu "
"comprimento é %d"

#: data.table.R:1208
msgid "Internal error -- item '%s' not found in names of list"
msgstr "Erro interno -- item '%s' não encontrado nos nomes da lista"

#: data.table.R:1237 data.table.R:1250
msgid "Internal error -- column(s) not found: %s"
msgstr "Erro interno – coluna(s) não encontrada(s): %s"

#: data.table.R:1262
msgid ""
"strptime() usage detected and wrapped with as.POSIXct(). This is to minimize"
" the chance of assigning POSIXlt columns, which use 40+ bytes to store one "
"date (versus 8 for POSIXct). Use as.POSIXct() (which will call strptime() as"
" needed internally) to avoid this warning."
msgstr ""
"Uso de strptime() detectado e agrupado com as.POSIXct(). Isso minimiza a "
"chance de atribuir colunas POSIXlt, que usam mais de 40 bytes para armazenar"
" uma data (contra 8 para POSIXct). Use as.POSIXct() (que chamará strptime() "
"conforme necessário internamente) para evitar esse aviso."

#: data.table.R:1279
msgid ""
"Variable '%s' is not found in calling scope. Looking in calling scope "
"because this symbol was prefixed with .. in the j= parameter."
msgstr ""
"A variável '%s' não foi encontrada no escopo de chamada. Procurando no "
"escopo de chamada porque este símbolo foi prefixado com .. no parâmetro j=."

#: data.table.R:1291
msgid "Internal error: xcolAns does not pass checks: %d/%d/%d/%s"
msgstr "Erro interno: xcolAns não passa nas verificações: %d/%d/%d/%s"

#: data.table.R:1301
msgid ""
"Internal error: irows is NULL when making join result at R level. Should no "
"longer happen now we use CsubsetDT earlier."
msgstr ""
"Erro interno: irows é NULL ao fazer o resultado da junção no nível R. Isso "
"não deveria mais acontecer agora, usamos CsubsetDT anteriormente."

#: data.table.R:1365
msgid ""
"j (the 2nd argument inside [...]) is a single symbol but column name '%1$s' "
"is not found. If you intended to select columns using a variable in calling "
"scope, please try DT[, ..%1$s]. The .. prefix conveys one-level-up similar "
"to a file system path."
msgstr ""
"j (o 2º argumento dentro de [...]) é um símbolo único, mas o nome da coluna "
"'%1$s' não foi encontrado. Se você pretendia selecionar colunas usando uma "
"variável na chamada do escopo, tente DT[, ..%1$s]. O prefixo .. transmite um"
" nível superior semelhante a um caminho do sistema de arquivos."

#: data.table.R:1420
msgid ""
"Internal error: j has created a data.table result containing a NULL column"
msgstr ""
"Erro interno: j criou um resultado de data.table contendo uma coluna NULL"

#: data.table.R:1430
msgid ""
"The column '.N' can't be grouped because it conflicts with the special .N "
"variable. Try setnames(DT,'.N','N') first."
msgstr ""
"A coluna '.N' não pode ser agrupada porque entra em conflito com a variável "
"especial .N. Tente setnames(DT,'.N','N') primeiro."

#: data.table.R:1431
msgid ""
"The column '.I' can't be grouped because it conflicts with the special .I "
"variable. Try setnames(DT,'.I','I') first."
msgstr ""
"A coluna '.I' não pode ser agrupada porque entra em conflito com a variável "
"especial .I. Tente setnames(DT,'.I','I') primeiro."

#: data.table.R:1448
msgid ""
"Note: forcing units=\"secs\" on implicit difftime by group; call difftime "
"explicitly to choose custom units"
msgstr ""
"Nota: forçando units=\"secs\" em difftime implícito por grupo; chame "
"difftime explicitamente para escolher unidades personalizadas"

#: data.table.R:1458
msgid "logical error. i is not data.table, but mult='all' and 'by'=.EACHI"
msgstr "erro lógico. i não é data.table, mas mult='all' e 'by'=.EACHI"

#: data.table.R:1481
msgid "Internal error: by= is missing"
msgstr "Erro interno: by= está ausente"

#: data.table.R:1485
msgid "Finding groups using forderv ..."
msgstr "Encontrando grupos usando forderv ..."

#: data.table.R:1499 data.table.R:1531
msgid ""
"Finding group sizes from the positions (can be avoided to save RAM) ..."
msgstr ""
"Encontrando tamanhos de grupos a partir das posições (pode ser evitado para "
"economizar RAM) ..."

#: data.table.R:1507
msgid "Getting back original order ..."
msgstr "Recuperando a ordem original..."

#: data.table.R:1519
msgid "Finding groups using uniqlist on key ..."
msgstr "Encontrando grupos usando uniqlist na chave ..."

#: data.table.R:1522
msgid "Internal error: byindex not the index name"
msgstr "Erro interno: byindex não é o nome do índice"

#: data.table.R:1523
msgid "Finding groups using uniqlist on index '%s' ..."
msgstr "Encontrando grupos usando uniqlist no índice '%s' ..."

#: data.table.R:1525
msgid "Internal error: byindex not found"
msgstr "Erro interno: byindex não encontrado"

#: data.table.R:1724
msgid "lapply optimization changed j from '%s' to '%s'"
msgstr "a otimização de lapply mudou j de '%s' para '%s'"

#: data.table.R:1726
msgid "lapply optimization is on, j unchanged as '%s'"
msgstr "a otimização de lapply está ativada, j inalterado como '%s'"

#: data.table.R:1736 data.table.R:1821
msgid "GForce optimized j to '%s' (see ?GForce)"
msgstr "GForce otimizou j para '%s' (veja ?GForce)"

#: data.table.R:1822
msgid ""
"GForce is on, but not activated for this query; left j unchanged (see "
"?GForce)"
msgstr ""
"O GForce está ativado, mas não disponível para esta consulta; deixou j "
"inalterado (veja ?GForce)"

#: data.table.R:1841
msgid ""
"Unable to optimize call to mean() and could be very slow. You must name "
"'na.rm' like that otherwise if you do mean(x,TRUE) the TRUE is taken to mean"
" 'trim' which is the 2nd argument of mean. 'trim' is not yet optimized."
msgstr ""
"Não foi possível otimizar a chamada de mean() e pode ser muito lento. Você "
"deve nomear 'na.rm' desta forma, caso contrário, se você usar mean(x,TRUE), "
"o TRUE é obtido para fazer uma média truncada, pois 'trim' é o 2º argumento "
"de mean. 'trim' ainda não está otimizado."

#: data.table.R:1845
msgid "Old mean optimization changed j from '%s' to '%s'"
msgstr "A otimização antiga de média mudou j de '%s' para '%s'"

#: data.table.R:1847
msgid "Old mean optimization is on, left j unchanged."
msgstr "A otimização antiga de média está ativada, j deixado inalterado."

#: data.table.R:1857
msgid "All optimizations are turned off"
msgstr "Todas as otimizações estão desativadas"

#: data.table.R:1858
msgid "Optimization is on but left j unchanged (single plain symbol): '%s'"
msgstr ""
"A otimização está ativada, mas j deixado inalterado (único símbolo simples):"
" '%s'"

#: data.table.R:1878
msgid "Internal error: length(irows)!=length(o__)"
msgstr "Erro interno: length(irows)!=length(o__)"

#: data.table.R:1887
msgid "Making each group and running j (GForce %s) ..."
msgstr "Fazendo cada grupo e executando j (GForce %s)..."

#: data.table.R:1983
msgid "setkey() after the := with keyby= ..."
msgstr "setkey() após := com keyby= ..."

#: data.table.R:1987
msgid ""
"The setkey() normally performed by keyby= has been skipped (as if by= was "
"used) because := is being used together with keyby= but the keyby= contains "
"some expressions. To avoid this warning, use by= instead, or provide "
"existing column names to keyby=."
msgstr ""
"O setkey() normalmente executado por keyby= foi ignorado (como se by= fosse "
"usado) porque := está sendo usado junto com keyby= mas keyby= contém algumas"
" expressões. Para evitar esse aviso, use by= ou forneça nomes de colunas "
"existentes para keyby=."

#: data.table.R:2002
msgid "Internal error: jvnames is length %d but ans is %d and bynames is %d"
msgstr "Erro interno: jvnames tem comprimento %d, mas ans é %d e bynames é %d"

#: data.table.R:2010
msgid "setkey() afterwards for keyby=.EACHI ..."
msgstr "setkey() depois para keyby=.EACHI ..."

#: data.table.R:2072
msgid "rownames and rownames.value cannot both be used at the same time"
msgstr "rownames e rownames.value não podem ser usados ao mesmo tempo"

#: data.table.R:2077
msgid ""
"length(rownames)==%d but nrow(DT)==%d. The rownames argument specifies a "
"single column name or number. Consider rownames.value= instead."
msgstr ""
"length(rownames)==%d, mas nrow(DT)==%d. O argumento rownames especifica um "
"único nome ou número de coluna. Considere usar rownames.value= em vez disso."

#: data.table.R:2081
msgid ""
"length(rownames)==0 but should be a single column name or number, or NULL"
msgstr ""
"length(rownames)==0, mas deve ser um nome ou número de única coluna, ou NULL"

#: data.table.R:2085
msgid ""
"rownames is TRUE but key has multiple columns %s; taking first column x[,1] "
"as rownames"
msgstr ""
"rownames é TRUE, mas a chave possui múltiplas colunas %s; obtendo a primeira"
" coluna x[,1] como rownames"

#: data.table.R:2095
msgid "'%s' is not a column of x"
msgstr "'%s' não é uma coluna de x"

#: data.table.R:2101
msgid ""
"as.integer(rownames)==%d which is outside the column number range "
"[1,ncol=%d]."
msgstr ""
"as.integer(rownames)==%d que está fora do intervalo de números de coluna "
"[1,ncol=%d]."

#: data.table.R:2106
msgid "length(rownames.value)==%d but should be nrow(x)==%d"
msgstr "length(rownames.value)==%d, mas deveria ser nrow(x)==%d"

#: data.table.R:2168
msgid ""
"Internal error: as.matrix.data.table length(X)==%d but a dimension is zero"
msgstr ""
"Erro interno: as.matrix.data.table com length(X)==%d, mas uma dimensão é "
"zero"

#: data.table.R:2204
msgid ""
"When i is a matrix in DT[i]<-value syntax, it doesn't make sense to provide "
"j"
msgstr ""
"Quando i é uma matriz na sintaxe DT[i]<-valor, não faz sentido fornecer j"

#: data.table.R:2214
msgid "j must be an atomic vector, see ?is.atomic"
msgstr "j deve ser um vetor atômico, veja ?is.atomic"

#: data.table.R:2215
msgid "NA in j"
msgstr "NA em j"

#: data.table.R:2221
msgid "j must be vector of column name or positions"
msgstr "j deve ser o vetor de posições ou nome de coluna"

#: data.table.R:2222
msgid ""
"Attempt to assign to column position greater than ncol(x). Create the column"
" by name, instead. This logic intends to catch (most likely) user errors."
msgstr ""
"Tente atribuir à coluna uma posição maior que ncol(x). Em vez disso, crie a "
"coluna por nome. Esta lógica pretende capturar (provavelmente) erros do "
"usuário."

#: data.table.R:2289
msgid ""
"data.table inherits from data.frame (from v1.5), but this data.table does "
"not. Has it been created manually (e.g. by using 'structure' rather than "
"'data.table') or saved to disk using a prior version of data.table?"
msgstr ""
"data.table herda de data.frame (desde v1.5), mas este data.table não. Ele "
"foi criado manualmente (por exemplo, usando 'structure' em vez de "
"'data.table') ou salvo em disco usando uma versão anterior de data.table?"

#: data.table.R:2298
msgid "attempting to assign invalid object to dimnames of a data.table"
msgstr "tentando atribuir objeto inválido a dimnames de um data.table"

#: data.table.R:2299
msgid "data.tables do not have rownames"
msgstr "data.tables não tem rownames"

#: data.table.R:2300 data.table.R:2678
msgid "Can't assign %d names to a %d-column data.table"
msgstr "Não é possível atribuir %d nomes a um data.table de %d colunas"

#: data.table.R:2379
msgid "'subset' must evaluate to logical"
msgstr "'subset' deve ser avaliado para tipo lógico"

#: data.table.R:2422
msgid "Argument 'invert' must be logical TRUE/FALSE"
msgstr "Argumento 'invert' deve ser lógico TRUE/FALSE"

#: data.table.R:2463
msgid "x argument must be a data.table"
msgstr "o argumento x deve ser um data.table"

#: data.table.R:2468
msgid "group length is 0 but data nrow > 0"
msgstr "o comprimento do grupo é 0, mas os dados têm nrow > 0"

#: data.table.R:2470
msgid ""
"passing 'f' argument together with 'by' is not allowed, use 'by' when split "
"by column in data.table and 'f' when split by external factor"
msgstr ""
"passar o argumento 'f' junto com 'by' não é permitido, use 'by' quando "
"dividido por coluna no data.table e 'f' quando dividido por fator externo"

#: data.table.R:2474
msgid "Either 'by' or 'f' argument must be supplied"
msgstr "O argumento 'by' ou 'f' deve ser fornecido"

#: data.table.R:2476
msgid "Column '.ll.tech.split' is reserved for split.data.table processing"
msgstr ""
"A coluna '.ll.tech.split' é reservada para processamento split.data.table"

#: data.table.R:2477
msgid "Column '.nm.tech.split' is reserved for split.data.table processing"
msgstr ""
"A coluna '.nm.tech.split' é reservada para processamento split.data.table"

#: data.table.R:2478
msgid "Argument 'by' must refer to column names in x"
msgstr "O argumento 'by' deve se referir aos nomes das colunas em x"

#: data.table.R:2479
msgid ""
"Argument 'by' must refer only to atomic-type columns, but the following "
"columns are non-atomic: %s"
msgstr ""
"O argumento 'by' deve referir-se apenas a colunas do tipo atômico, mas as "
"seguintes colunas não são atômicas: %s"

#: data.table.R:2524
msgid "Processing split.data.table with: %s"
msgstr "Processando split.data.table com: %s"

#: data.table.R:2609
msgid ""
"x is not a data.table|frame. Shallow copy is a copy of the vector of column "
"pointers (only), so is only meaningful for data.table|frame"
msgstr ""
"x não é um data.table|frame. A cópia rasa é uma cópia do vetor de ponteiros "
"de coluna (apenas), portanto, só é significativa para data.table|frame"

#: data.table.R:2618
msgid "setalloccol attempting to modify `*tmp*`"
msgstr "setalloccol tentando modificar `*tmp*`"

#: data.table.R:2653
msgid ""
"Input is a length=1 logical that points to the same address as R's global "
"value. Therefore the attribute has not been set by reference, rather on a "
"copy. You will need to assign the result back to a variable. See issue "
"#1281."
msgstr ""
"A entrada é um tipo lógico de comprimento 1 que aponta para o mesmo endereço"
" que o valor global de R. Portanto, o atributo não foi definido por "
"referência, mas sim por uma cópia. Você precisará atribuir o resultado de "
"volta a uma variável. Consulte o issue #1281."

#: data.table.R:2668
msgid "x is not a data.table or data.frame"
msgstr "x não é um data.table ou data.frame"

#: data.table.R:2670
msgid "x has %d columns but its names are length %d"
msgstr "x tem %d colunas, mas seus nomes têm comprimento %d"

#: data.table.R:2677
msgid "Passed a vector of type '%s'. Needs to be type 'character'."
msgstr "Passou um vetor do tipo '%s'. Precisa ser do tipo 'character'."

#: data.table.R:2690
msgid "'new' is not a character vector or a function"
msgstr "'new' não é um vetor de caracteres ou uma função"

#: data.table.R:2692
msgid "NA in 'new' at positions %s"
msgstr "NA em 'new' nas posições %s"

#: data.table.R:2693
msgid "Some duplicates exist in 'old': %s"
msgstr "Existem algumas duplicatas em 'old': %s"

#: data.table.R:2695
msgid "'old' is type %s but should be integer, double or character"
msgstr "'old' é do tipo %s, mas deve ser inteiro, double ou caractere"

#: data.table.R:2696
msgid "'old' is length %d but 'new' is length %d"
msgstr "'old' tem comprimento %d, mas 'new' tem comprimento %d"

#: data.table.R:2697
msgid "NA (or out of bounds) in 'old' at positions %s"
msgstr "NA (ou fora dos limites) em 'old' nas posições %s"

#: data.table.R:2700
msgid ""
"Item %d of 'old' is '%s' which appears several times in column names. Just "
"the first will be changed. There are %d other items in 'old' that are also "
"duplicated in column names."
msgstr ""
"O item %d de 'old' é '%s' que aparece várias vezes nos nomes das colunas. "
"Apenas o primeiro será alterado. Existem %d outros itens em 'old' que também"
" estão duplicados nos nomes das colunas."

#: data.table.R:2708
msgid ""
"Items of 'old' not found in column names: %s. Consider skip_absent=TRUE."
msgstr ""
"Itens de 'old' não encontrados nos nomes das colunas: %s. Considere "
"skip_absent=TRUE."

#: data.table.R:2718
msgid "Internal error: length(i)!=length(new)"
msgstr "Erro interno: length(i)!=length(new)"

#: data.table.R:2747
msgid ""
"x has some duplicated column name(s): %s. Please remove or rename the "
"duplicate(s) and try again."
msgstr ""
"x tem alguns nomes de coluna duplicados: %s. Remova ou renomeie as "
"duplicatas e tente novamente."

#: data.table.R:2749
msgid "Provide either before= or after= but not both"
msgstr "Forneça before= ou after=, mas não ambos"

#: data.table.R:2751
msgid ""
"before=/after= accept a single column name or number, not more than one"
msgstr ""
"before=/after= aceitam um único nome ou número de coluna, não mais do que um"

#: data.table.R:2806
msgid "Input is %s but should be a plain list of items to be stacked"
msgstr ""
"A entrada é %s, mas deve ser uma lista simples de itens a serem empilhados"

#: data.table.R:2810
msgid ""
"idcol must be a logical or character vector of length 1. If logical TRUE the"
" id column will named '.id'."
msgstr ""
"idcol deve ser um vetor de valores lógicos ou caracteres de comprimento 1. "
"Se for lógico TRUE, o id da coluna será denominada '.id'."

#: data.table.R:2815
msgid "use.names=NA invalid"
msgstr "use.names=NA inválido"

#: data.table.R:2817
msgid ""
"use.names='check' cannot be used explicitly because the value 'check' is new"
" in v1.12.2 and subject to change. It is just meant to convey default "
"behavior. See ?rbindlist."
msgstr ""
"use.names='check' não pode ser usado explicitamente porque o valor 'check' é"
" novo na v1.12.2 e está sujeito a alterações. O objetivo é apenas transmitir"
" o comportamento padrão. Consulte ?rbindlist."

#: data.table.R:2832
msgid ""
"Check that is.data.table(DT) == TRUE. Otherwise, :=, `:=`(...) and let(...) "
"are defined for use in j, once only and in particular ways. See "
"help(\":=\")."
msgstr ""
"Verifique se is.data.table(DT) == TRUE. Caso contrário, :=, `:=`(...) e "
"let(...) são definidos para uso em j, apenas uma vez e de maneiras "
"específicas. Veja help(\":=\")."

#: data.table.R:2838
msgid ""
"setDF only accepts data.table, data.frame or list of equal length as input"
msgstr ""
"setDF aceita apenas data.table, data.frame ou lista de igual comprimento "
"como entrada"

#: data.table.R:2839
msgid "rownames contains duplicates"
msgstr "rownames contém duplicatas"

#: data.table.R:2846 data.table.R:2857 data.table.R:2880
msgid "rownames incorrect length; expected %d names, got %d"
msgstr "rownames com comprimento incorreto; esperava %d nomes, obteve %d"

#: data.table.R:2865
msgid "All elements in argument 'x' to 'setDF' must be of same length"
msgstr ""
"Todos os elementos no argumento 'x' para 'setDF' devem ter o mesmo "
"comprimento"

#: data.table.R:2894
msgid "Cannot find symbol %s"
msgstr "Não foi possível encontrar o símbolo %s"

#: data.table.R:2901
msgid ""
"Cannot convert '%1$s' to data.table by reference because binding is locked. "
"It is very likely that '%1$s' resides within a package (or an environment) "
"that is locked to prevent modifying its variable bindings. Try copying the "
"object to your current environment, ex: var <- copy(var) and then using "
"setDT again."
msgstr ""
"Não é possível converter '%1$s' em data.table por referência porque o "
"vínculo está travado. É muito provável que '%1$s' resida em um pacote (ou "
"ambiente) que esteja travado para evitar a modificação de seus vínculos de "
"variáveis. Tente copiar o objeto para o seu ambiente atual, ex: var <- "
"copy(var) e depois usar setDT novamente."

#: data.table.R:2908
msgid ""
"Some columns are a multi-column type (such as a matrix column): %s. setDT "
"will retain these columns as-is but subsequent operations like grouping and "
"joining may fail. Please consider as.data.table() instead which will create "
"a new column for each embedded column."
msgstr ""
"Algumas colunas são do tipo multicolunas (como uma coluna de matriz): %s. "
"setDT manterá essas colunas como estão, mas operações subsequentes, como "
"agrupamento e junção, poderão falhar. Considere usar as.data.table(), que "
"criará uma nova coluna para cada coluna incorporada."

#: data.table.R:2940
msgid ""
"Column %d is of POSIXlt type. Please convert it to POSIXct using as.POSIXct "
"and run setDT again. We do not recommend use of POSIXlt at all because it "
"uses 40 bytes to store one date."
msgstr ""
"A coluna %d é do tipo POSIXlt. Por favor, converta-o para POSIXct usando "
"as.POSIXct e execute setDT novamente. Não recomendamos o uso de POSIXlt "
"porque ele usa 40 bytes para armazenar uma data."

#: data.table.R:2946
msgid ""
"All elements in argument 'x' to 'setDT' must be of same length, but the profile of input lengths (length:frequency) is: %s\n"
"The first entry with fewer than %d entries is %d."
msgstr ""
"Todos os elementos no argumento 'x' para 'setDT' devem ter o mesmo comprimento, mas o perfil dos comprimentos de entrada (comprimento:frequência) é: %s\n"
"A primeira entrada com menos de %d entradas é %d."

#: data.table.R:2963
msgid ""
"Argument 'x' to 'setDT' should be a 'list', 'data.frame' or 'data.table'"
msgstr ""
"O argumento 'x' para 'setDT' deve ser uma 'list', 'data.frame' ou "
"'data.table'"

#: data.table.R:2978
msgid "Item '%s' not found in names of input list"
msgstr "Item '%s' não encontrado nos nomes da lista de entradas"

#: data.table.R:3003 data.table.R:3028
msgid "'prefix' must be NULL or a character vector of length 1."
msgstr "'prefix' deve ser NULL ou um vetor de caracteres de comprimento 1."

#: data.table.R:3006 data.table.R:3031
msgid "x is a single vector, non-NULL 'cols' doesn't make sense."
msgstr "x é um único vetor, 'cols' não NULL não faz sentido."

#: data.table.R:3010 data.table.R:3035
msgid "x is a list, 'cols' cannot be 0-length."
msgstr "x é uma lista, 'cols' não pode ter comprimento 0."

#: data.table.R:3144
msgid ""
"RHS of %s is length %d which is not 1 or nrow (%d). For robustness, no "
"recycling is allowed (other than of length 1 RHS). Consider %%in%% instead."
msgstr ""
"Lado direito (RHS) de %s tem comprimento %d que não é 1 ou nrow (%d). Para "
"maior robustez, nenhuma reciclagem é permitida (exceto em lado direito de "
"comprimento 1). Considere %%in%% em vez disso."

#: data.table.R:3172
msgid ""
"Internal error in .isFastSubsettable. Please report to data.table developers"
msgstr ""
"Erro interno em .isFastSubsettable. Por favor, relate aos desenvolvedores do"
" data.table"

#: data.table.R:3176
msgid ""
"Subsetting optimization disabled because the cross-product of RHS values "
"exceeds 1e4, causing memory problems."
msgstr ""
"A otimização da divisão em subconjuntos foi desativada porque o produto "
"vetorial dos valores do lado direito (RHS) excede 1e4, causando problemas de"
" memória."

#: data.table.R:3194
msgid "Optimized subsetting with key %s"
msgstr "Divisão de subconjunto otimizada com chave %s"

#: data.table.R:3213 data.table.R:3223
msgid "Optimized subsetting with index '%s'"
msgstr "Divisão de subconjunto otimizada com índice '%s'"

#: data.table.R:3219
msgid "Creating new index '%s'"
msgstr "Criando novo índice '%s'"

#: data.table.R:3220
msgid "Creating index %s done in ..."
msgstr "Criação do índice %s feita em ..."

#: data.table.R:3259
msgid ""
"'on' argument should be a named atomic vector of column names indicating "
"which columns in 'i' should be joined with which columns in 'x'."
msgstr ""
"O argumento 'on' deve ser um vetor atômico nomeado de nomes de colunas "
"indicando quais colunas em 'i' devem ser unidas a quais colunas em 'x'."

#: data.table.R:3300
msgid ""
"Found more than one operator in one 'on' statement: %s. Please specify a "
"single operator."
msgstr ""
"Encontrado mais de um operador em uma instrução 'on': %s. Especifique um "
"único operador."

#: data.table.R:3323
msgid ""
"'on' contains no column name: %s. Each 'on' clause must contain one or two "
"column names."
msgstr ""
"'on' não contém nome de coluna: %s. Cada cláusula 'on' deve conter um ou "
"dois nomes de coluna."

#: data.table.R:3325
msgid ""
"'on' contains more than 2 column names: %s. Each 'on' clause must contain "
"one or two column names."
msgstr ""
"'on' contém mais de 2 nomes de colunas: %s. Cada cláusula 'on' deve conter "
"um ou dois nomes de coluna."

#: data.table.R:3330
msgid "Invalid join operators %s. Only allowed operators are %s."
msgstr ""
"Operadores de junção inválidos %s. Somente operadores permitidos são %s."
