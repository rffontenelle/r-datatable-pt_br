# 
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# 
msgid ""
msgstr ""
"Project-Id-Version: assign 0.0\n"
"POT-Creation-Date: 2024-02-15 21:22-0300\n"
"PO-Revision-Date: 2024-04-10 02:58+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/rafaelff1/teams/190680/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % 1000000 == 0 ? 1 : 2;\n"

#: assign.c:7
msgid "Internal error: finalizer hasn't received an ExternalPtr"
msgstr "Erro interno: finalizador não recebeu um ExternalPtr"

#: assign.c:9
msgid "Internal error: finalizer's ExternalPtr doesn't see names in tag"
msgstr "Erro interno: ExternalPtr do finalizador não vê nomes na tag"

#: assign.c:12
#, c-format
msgid "Internal error: finalizer sees l=%d, tl=%d"
msgstr "Erro interno: finalizador vê l=%d, tl=%d"

#: assign.c:121
msgid ""
".internal.selfref ptr is NULL. This is expected and normal for a data.table "
"loaded from disk. Please remember to always setDT() immediately after "
"loading to prevent unexpected behavior. If this table was not loaded from "
"disk or you've already run setDT(), please report to data.table issue "
"tracker.\n"
msgstr ""
"ptr de .internal.selfref é NULL. Isso é esperado e normal para um data.table"
" carregado do disco. Lembre-se de sempre executar setDT() imediatamente após"
" o carregamento para evitar comportamento inesperado. Se esta tabela não foi"
" carregada do disco ou você já executou setDT(), informe ao rastreador de "
"problemas do data.table.\n"

#: assign.c:124
msgid "Internal error: .internal.selfref ptr is neither NULL nor R_NilValue"
msgstr "Erro interno: ptr de .internal.selfref não é NULL nem R_NilValue"

#: assign.c:126
msgid ""
"Internal error: .internal.selfref tag is neither NULL nor a character vector"
msgstr ""
"Erro interno: tag de .internal.selfref não é NULL nem um vetor de caracteres"

#: assign.c:179
msgid "Internal error: length(names)>0 but <length(dt)"
msgstr "Erro interno: length(names)>0, mas <length(dt)"

#: assign.c:207
msgid "alloccol has been passed a NULL dt"
msgstr "alloccol recebeu um dt NULL"

#: assign.c:208
msgid "dt passed to alloccol isn't type VECSXP"
msgstr "dt passado para alloccol não é do tipo VECSXP"

#: assign.c:210
msgid ""
"dt passed to alloccol has no class attribute. Please report result of "
"traceback() to data.table issue tracker."
msgstr ""
"dt passado para alloccol não possui nenhum atributo de classe. Por favor, "
"relate o resultado de traceback() para o rastreador de problemas do "
"data.table."

#: assign.c:215 assign.c:315
#, c-format
msgid "Internal error: length of names (%d) is not length of dt (%d)"
msgstr ""
"Erro interno: o comprimento dos nomes (%d) não é tem o comprimento de dt "
"(%d)"

#: assign.c:225
msgid "Internal error, tl of class is marked but tl<0."
msgstr "Erro interno, tl da classe está marcado, mas tl<0."

#: assign.c:226
#, c-format
msgid ""
"Internal error, please report (including result of sessionInfo()) to "
"data.table issue tracker: tl (%d) < l (%d) but tl of class is marked."
msgstr ""
"Erro interno, relate (incluindo o resultado de sessionInfo()) ao rastreador "
"de problemas data.table: tl (%d) < l (%d), mas tl da classe está marcado."

#: assign.c:227
#, c-format
msgid ""
"tl (%d) is greater than 10,000 items over-allocated (l = %d). If you didn't "
"set the datatable.alloccol option to be very large, please report to "
"data.table issue tracker including the result of sessionInfo()."
msgstr ""
"tl (%d) é superior a 10.000 itens superalocados (l = %d). Se você não "
"definiu a opção datatable.alloccol como muito grande, relate ao rastreador "
"de problemas do data.table incluindo o resultado de sessionInfo()."

#: assign.c:229
#, c-format
msgid ""
"Attempt to reduce allocation from %d to %d ignored. Can only increase "
"allocation via shallow copy. Please do not use DT[...]<- or DT$someCol<-. "
"Use := inside DT[...] instead."
msgstr ""
"Tentativa de reduzir a alocação de %d para %d foi ignorada. Só é possível "
"aumentar a alocação por meio de cópia rasa. Por favor, não use DT[...]<- ou "
"DT$someCol<-. Use := dentro de DT[...] em vez disso."

#: assign.c:237
msgid ""
"Has getOption('datatable.alloccol') somehow become unset? It should be a "
"number, by default 1024."
msgstr ""
"GetOption('datatable.alloccol') de alguma forma deixou de estar definido? "
"Deveria ser um número, por padrão 1024."

#: assign.c:239
#, c-format
msgid ""
"getOption('datatable.alloccol') should be a number, by default 1024. But its"
" type is '%s'."
msgstr ""
"getOption('datatable.alloccol') deveria ser um número, por padrão 1024. Mas "
"seu tipo é \"%s\"."

#: assign.c:241
#, c-format
msgid ""
"getOption('datatable.alloc') is a numeric vector ok but its length is %d. "
"Its length should be 1."
msgstr ""
"getOption('datatable.alloc') é um vetor numérico, mas seu comprimento é %d. "
"Seu comprimento deve ser 1."

#: assign.c:244
#, c-format
msgid "getOption('datatable.alloc')==%d.  It must be >=0 and not NA."
msgstr "getOption('datatable.alloc')==%d. Deve ser >=0 e não NA."

#: assign.c:250
#, c-format
msgid "%s must be TRUE or FALSE"
msgstr "%s deve ser TRUE ou FALSE"

#: assign.c:298
msgid "assign has been passed a NULL dt"
msgstr "à atribuição foi passado um dt NULL"

#: assign.c:299
msgid "dt passed to assign isn't type VECSXP"
msgstr "dt passado para a atribuição não é do tipo VECSXP"

#: assign.c:301
msgid ""
".SD is locked. Updating .SD by reference using := or set are reserved for "
"future use. Use := in j directly. Or use copy(.SD) as a (slow) last resort, "
"until shallow() is exported."
msgstr ""
".SD está bloqueado. A atualização de .SD por referência usando := ou set "
"está reservada para uso futuro. Use := em j diretamente. Ou use copy(.SD) "
"como um como último recurso (lento), até que shallow() seja exportado."

#: assign.c:309
msgid "Internal error: dt passed to Cassign is not a data.table or data.frame"
msgstr "Erro interno: dt passado para Cassign não é data.table ou data.frame"

#: assign.c:313
msgid "dt passed to assign has no names"
msgstr "dt passado para assign não tem nomes"

#: assign.c:317
msgid ""
"data.table is NULL; malformed. A null data.table should be an empty list. "
"typeof() should always return 'list' for data.table."
msgstr ""
"data.table é NULL; malformado. Um data.table nulo deve ser uma lista vazia. "
"typeof() deve sempre retornar \"list\" para data.table."

#: assign.c:326
#, c-format
msgid "Assigning to all %d rows\n"
msgstr "Atribuindo a todas as %d linhas\n"

#: assign.c:331
msgid ""
"Coerced i from numeric to integer. Please pass integer for efficiency; e.g.,"
" 2L rather than 2"
msgstr ""
"Foi feita coerção de i de numérico para inteiro. Por favor, passe um número "
"inteiro para obter eficiência; por exemplo, 2L em vez de 2"

#: assign.c:334
#, c-format
msgid ""
"i is type '%s'. Must be integer, or numeric is coerced with warning. If i is"
" a logical subset, simply wrap with which(), and take the which() outside "
"the loop if possible for efficiency."
msgstr ""
"i é do tipo '%s'. Deve ser inteiro ou é feita coerção de numérico com aviso."
" Se i for um subconjunto lógico, simplesmente envolva which() e obtenha "
"which() por fora do loop, se possível, para maior eficiência."

#: assign.c:340
#, c-format
msgid "i[%d] is %d which is out of range [1,nrow=%d]"
msgstr "i[%d] é %d, o qual está fora do intevalo [1,nrow=%d]"

#: assign.c:343
#, c-format
msgid "Assigning to %d row subset of %d rows\n"
msgstr "Atribuindo para a linha %d que é subconjunto de %d linhas\n"

#: assign.c:351
#, c-format
msgid "Added %d new column%s initialized with all-NA\n"
msgstr "Adicionada(s) %d nova(s) coluna%s inicializada toda com NA\n"

#: assign.c:356
msgid "length(LHS)==0; no columns to delete or assign RHS to."
msgstr "length(LHS)==0; nenhuma coluna para excluir ou atribuir RHS."

#: assign.c:370
msgid ""
"set() on a data.frame is for changing existing columns, not adding new ones."
" Please use a data.table for that. data.table's are over-allocated and don't"
" shallow copy."
msgstr ""
"set() em um data.frame serve para alterar colunas existentes, não para "
"adicionar novas. Por favor, use um data.table para isso. data.table são "
"superalocados e não são copiados superficialmente."

#: assign.c:381
msgid ""
"Coerced j from numeric to integer. Please pass integer for efficiency; e.g.,"
" 2L rather than 2"
msgstr ""
"Foi feita coerção do j de numérico para inteiro. Por favor, passe um número "
"inteiro obter eficiência; por exemplo, 2L em vez de 2"

#: assign.c:384
#, c-format
msgid ""
"j is type '%s'. Must be integer, character, or numeric is coerced with "
"warning."
msgstr ""
"j é do tipo \"%s\". Deve ser inteiro, caractere ou numérico é coagido com "
"aviso."

#: assign.c:386
msgid ""
"Can't assign to the same column twice in the same query (duplicates "
"detected)."
msgstr ""
"Não é possível atribuir à mesma coluna duas vezes na mesma consulta "
"(duplicatas detectadas)."

#: assign.c:387
msgid "newcolnames is supplied but isn't a character vector"
msgstr "newcolnames é fornecido, mas não é um vetor de caracteres"

#: assign.c:389
#, c-format
msgid "RHS_list_of_columns == %s\n"
msgstr "RHS_list_of_columns == %s\n"

#: assign.c:394
#, c-format
msgid ""
"RHS_list_of_columns revised to true because RHS list has 1 item which is "
"NULL, or whose length %d is either 1 or targetlen (%d). Please unwrap RHS.\n"
msgstr ""
"RHS_list_of_columns revisado para true porque a lista no lado direito (RHS) "
"tem 1 item que é NULL ou cujo comprimento %d é 1 ou targetlen (%d). Por "
"favor, desembrulhe o lado direito.\n"

#: assign.c:399
#, c-format
msgid ""
"Supplied %d columns to be assigned an empty list (which may be an empty "
"data.table or data.frame since they are lists too). To delete multiple "
"columns use NULL instead. To add multiple empty list columns, use "
"list(list())."
msgstr ""
"%d colunas fornecidas para serem atribuídas a uma lista vazia (que pode ser "
"um data.table ou data.frame vazio, pois também são listas). Para excluir "
"várias colunas, use NULL. Para adicionar várias colunas de lista vazias, use"
" list(list())."

#: assign.c:404
#, c-format
msgid "Recycling single RHS list item across %d columns. Please unwrap RHS.\n"
msgstr ""
"Reciclando um único item da lista lado direito (RHS) em %d colunas. Por "
"favor, desembrulhe o lado direito.\n"

#: assign.c:406
#, c-format
msgid ""
"Supplied %d columns to be assigned %d items. Please see NEWS for v1.12.2."
msgstr ""
"Fornecidas %d colunas para serem atribuídos %d itens. Por favor, veja NEWS "
"para v1.12.2."

#: assign.c:414
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. "
"set() on a data.frame is for changing existing columns, not adding new ones."
" Please use a data.table for that."
msgstr ""
"Item %d da coluna números em j é %d, o que está fora da faixa [1,ncol=%d]. "
"set() em um data.frame é para alterar colunas existentes, não para adicionar"
" novas. Por favor, use um data.table para isso."

#: assign.c:415
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. Use"
" column names instead in j to add new columns."
msgstr ""
"Item %d da coluna números em j é %d, o que está fora da faixa [1,ncol=%d]. "
"Use nomes de coluna em vez disso em j para adicionar novas colunas."

#: assign.c:420
msgid "When deleting columns, i should not be provided"
msgstr "Ao excluir colunas, i não deve ser fornecido"

#: assign.c:426
#, c-format
msgid ""
"RHS of assignment to existing column '%s' is zero length but not NULL. If "
"you intend to delete the column use NULL. Otherwise, the RHS must have "
"length > 0; e.g., NA_integer_. If you are trying to change the column type "
"to be an empty list column then, as with all column type changes, provide a "
"full length RHS vector such as vector('list',nrow(DT)); i.e., 'plonk' in the"
" new column."
msgstr ""
"O lado direito (RHS) da atribuição à coluna existente '%s' tem comprimento "
"zero, mas não é NULL. Se você pretende excluir a coluna, use NULL. Caso "
"contrário, o lado direito (RHS) deverá ter comprimento > 0; por exemplo, "
"NA_integer_. Se você estiver tentando alterar o tipo de coluna para uma "
"coluna de lista vazia, como acontece com todas as alterações de tipo de "
"coluna, forneça no lado direito (RHS) um vetor de comprimento completo, como"
" vector('list',nrow(DT)); ou seja, 'plonk' na nova coluna."

#: assign.c:431
#, c-format
msgid ""
"Internal error in assign.c: length(newcolnames)=%d, length(names)=%d, "
"coln=%d"
msgstr ""
"Erro interno em assign.c: length(newcolnames)=%d, length(names)=%d, coln=%d"

#: assign.c:433
#, c-format
msgid "Column '%s' does not exist to remove"
msgstr "A coluna '%s' não existe para ser removida"

#: assign.c:441
#, c-format
msgid "%d column matrix RHS of := will be treated as one vector"
msgstr ""
"Coluna %d da matriz do lado direito (RHS) de := será tratada como um vetor"

#: assign.c:446
#, c-format
msgid ""
"Can't assign to column '%s' (type 'factor') a value of type '%s' (not "
"character, factor, integer or numeric)"
msgstr ""
"Não é possível atribuir para a coluna '%s' (tipo 'factor') um valor de tipo "
"'%s' (não um caractere, fator, inteiro ou numérico)"

#: assign.c:452
#, c-format
msgid ""
"Supplied %d items to be assigned to %d items of column '%s'. If you wish to "
"'recycle' the RHS please use rep() to make this intent clear to readers of "
"your code."
msgstr ""
"Fornecidos %d itens a serem atribuídos a %d itens da coluna '%s'. Se você "
"deseja fazer 'recycle' o lado direito (RHS), use rep() para deixar essa "
"intenção clara para os leitores do seu código."

#: assign.c:462
msgid ""
"This data.table has either been loaded from disk (e.g. using "
"readRDS()/load()) or constructed manually (e.g. using structure()). Please "
"run setDT() or setalloccol() on it first (to pre-allocate space for new "
"columns) before assigning by reference to it."
msgstr ""
"Este data.table foi carregado do disco (por exemplo, usando "
"readRDS()/load()) ou construído manualmente (por exemplo, usando "
"Structure()). Execute setDT() ou setalloccol() nele primeiro (para pré-"
"alocar espaço para novas colunas) antes de atribuir por referência a ele."

#: assign.c:463
#, c-format
msgid ""
"Internal error: oldtncol(%d) < oldncol(%d). Please report to data.table "
"issue tracker, including result of sessionInfo()."
msgstr ""
"Erro interno: oldncol(%d) < oldncol(%d). Por favor, relate ao rastreador de "
"problemas do data.table, incluindo o resultado de sessionInfo()."

#: assign.c:465
#, c-format
msgid ""
"truelength (%d) is greater than 10,000 items over-allocated (length = %d). "
"See ?truelength. If you didn't set the datatable.alloccol option very large,"
" please report to data.table issue tracker including the result of "
"sessionInfo()."
msgstr ""
"truelength (%d) é maior que 10.000 itens superalocados (length = %d). "
"Consulte ?truelength. Se você não definiu a opção datatable.alloccol muito "
"grande, relate no rastreador de problemas do data.table incluindo o "
"resultado de sessionInfo()."

#: assign.c:467
#, c-format
msgid ""
"Internal error: DT passed to assign has not been allocated enough column "
"slots. l=%d, tl=%d, adding %d"
msgstr ""
"Erro interno: O DT passado para atribuição não recebeu slots de coluna "
"suficientes. l=%d, tl=%d, adicionando %d"

#: assign.c:469
msgid ""
"It appears that at some earlier point, names of this data.table have been "
"reassigned. Please ensure to use setnames() rather than names<- or "
"colnames<-. Otherwise, please report to data.table issue tracker."
msgstr ""
"Parece que em algum momento anterior, os nomes desta data.table foram "
"reatribuídos. Certifique-se de usar setnames() em vez de names<- ou "
"colnames<-. Caso contrário, informe no rastreador de problemas do "
"data.table."

#: assign.c:474
#, c-format
msgid "Internal error: selfrefnames is ok but tl names [%lld] != tl [%d]"
msgstr ""
"Erro interno: selfrefnames está certo, mas names de tl [%lld] != tl [%d]"

#: assign.c:493
msgid ""
"Internal error: earlier error 'When deleting columns, i should not be "
"provided' did not happen."
msgstr ""
"Erro interno: o erro anterior 'Ao excluir colunas, i não deve ser fornecido'"
" não ocorreu."

#: assign.c:504
#, c-format
msgid ""
"RHS for item %d has been duplicated because NAMED==%d MAYBE_SHARED==%d, but "
"then is being plonked. length(values)==%d; length(cols)==%d)\n"
msgstr ""
"O lado direito (RHS) para o item %d foi duplicado porque NAMED==%d "
"MAYBE_SHARED==%d, mas depois está sendo plonked. length(values)==%d; "
"length(cols)==%d)\n"

#: assign.c:509
#, c-format
msgid "Direct plonk of unnamed RHS, no copy. NAMED==%d, MAYBE_SHARED==%d\n"
msgstr ""
"Plonk direto de lado direito (RHS) sem nome, sem cópia. NAMED==%d, "
"MAYBE_SHARED==%d\n"

#: assign.c:578
#, c-format
msgid ""
"Dropping index '%s' as it doesn't have '__' at the beginning of its name. It"
" was very likely created by v1.9.4 of data.table.\n"
msgstr ""
"Descartando o índice \"%s\" porque ele não tem \"__\" no início do nome. "
"Muito provavelmente foi criado pela versão 1.9.4 do data.table.\n"

#: assign.c:586
msgid "Internal error: index name ends with trailing __"
msgstr "Erro interno: o nome do índice termina com __ à direita"

#: assign.c:591
msgid "Internal error: Couldn't allocate memory for s4."
msgstr "Erro interno: não foi possível alocar memória para s4."

#: assign.c:602
msgid "Internal error: Couldn't allocate memory for s5."
msgstr "Erro interno: não foi possível alocar memória para s5."

#: assign.c:623 assign.c:639
#, c-format
msgid "Dropping index '%s' due to an update on a key column\n"
msgstr "Descartando o índice \"%s\" devido a uma atualização em uma coluna-chave\n"

#: assign.c:632
#, c-format
msgid "Shortening index '%s' to '%s' due to an update on a key column\n"
msgstr ""
"Reduzindo o índice \"%s\" para \"%s\" devido a uma atualização em uma "
"coluna-chave\n"

#: assign.c:662
#, c-format
msgid ""
"Internal error: %d column numbers to delete not now in strictly increasing "
"order. No-dups were checked earlier."
msgstr ""
"Erro interno: %d números de coluna a serem excluídos agora não estão em "
"ordem rigorosamente crescente. Verificação de não duplicata foi feita "
"anteriormente."

#: assign.c:690
#, c-format
msgid "target vector"
msgstr ""

#: assign.c:690
#, c-format
msgid "column %d named '%s'"
msgstr ""

#: assign.c:706
#, c-format
msgid ""
"Internal error memrecycle: sourceStart=%d sourceLen=%d length(source)=%d"
msgstr ""
"Erro interno de memrecycle: sourceStart=%d sourceLen=%d length(source)=%d"

#: assign.c:708
#, c-format
msgid "Internal error memrecycle: start=%d len=%d length(target)=%d"
msgstr "Erro interno de memrecycle: start=%d len=%d length(target)=%d"

#: assign.c:711
#, c-format
msgid ""
"Internal error: recycle length error not caught earlier. slen=%d len=%d"
msgstr ""

#: assign.c:715
msgid "Internal error: memrecycle has received NULL colname"
msgstr "Erro interno: memrecycle recebeu nome de coluna NULL"

#: assign.c:724
#, c-format
msgid ""
"Cannot assign 'factor' to '%s'. Factors can only be assigned to factor, "
"character or list columns."
msgstr ""
"Não é possível atribuir \"factor\" a \"%s\". Os fatores só podem ser "
"atribuídos a colunas de fator, caractere ou lista."

#: assign.c:738
#, c-format
msgid ""
"Assigning factor numbers to %s. But %d is outside the level range [1,%d]"
msgstr ""

#: assign.c:747
#, c-format
msgid ""
"Assigning factor numbers to %s. But %f is outside the level range [1,%d], or"
" is not a whole number."
msgstr ""

#: assign.c:753
#, c-format
msgid ""
"Cannot assign '%s' to 'factor'. Factor columns can be assigned factor, "
"character, NA in any type, or level numbers."
msgstr ""
"Não é possível atribuir \"%s\" a \"factor\". As colunas de fator podem "
"receber fator, caractere, NA em qualquer tipo ou números de nível."

#: assign.c:774
msgid ""
"Internal error: levels of target are either not unique or have truelength<0"
msgstr ""
"Erro interno: os níveis de destino não são exclusivos ou têm truelength<0"

#: assign.c:813
msgid ""
"Unable to allocate working memory of %zu bytes to combine factor levels"
msgstr ""

#: assign.c:820
msgid "Internal error: extra level check sum failed"
msgstr "Erro interno: falha na soma de verificação de nível extra"

#: assign.c:839
#, c-format
msgid "Coercing 'character' RHS to '%s' to match the type of %s."
msgstr ""

#: assign.c:846
#, c-format
msgid "Cannot coerce 'list' RHS to 'integer64' to match the type of %s."
msgstr ""

#: assign.c:851
#, c-format
msgid "Coercing 'list' RHS to '%s' to match the type of %s."
msgstr ""

#: assign.c:856
#, c-format
msgid "Zero-copy coerce when assigning '%s' to '%s' %s.\n"
msgstr ""

#: assign.c:958
#, c-format
msgid "type '%s' cannot be coerced to '%s'"
msgstr "o tipo \"%s\" não pode ser coagido para \"%s\""

#: assign.c:1116
#, c-format
msgid "Unsupported column type in assign.c:memrecycle '%s'"
msgstr "Tipo de coluna não suportado em assign.c:memrecycle \"%s\""

#: assign.c:1170
#, c-format
msgid "Internal error: writeNA passed a vector of type '%s'"
msgstr ""

#: assign.c:1201
#, c-format
msgid ""
"Internal error: savetl_init checks failed (%d %d %p %p). please report to "
"data.table issue tracker."
msgstr ""

#: assign.c:1209
#, c-format
msgid "Failed to allocate initial %d items in savetl_init"
msgstr ""

#: assign.c:1218
#, c-format
msgid ""
"Internal error: reached maximum %d items for savetl. Please report to "
"data.table issue tracker."
msgstr ""

#: assign.c:1225
#, c-format
msgid "Failed to realloc saveds to %d items in savetl"
msgstr ""

#: assign.c:1231
#, c-format
msgid "Failed to realloc savedtl to %d items in savetl"
msgstr ""

#: assign.c:1254
msgid "x must be a character vector"
msgstr ""

#: assign.c:1255
msgid "'which' must be an integer vector"
msgstr ""

#: assign.c:1256
msgid "'new' must be a character vector"
msgstr ""

#: assign.c:1257
#, c-format
msgid "'new' is length %d. Should be the same as length of 'which' (%d)"
msgstr ""

#: assign.c:1260
#, c-format
msgid ""
"Item %d of 'which' is %d which is outside range of the length %d character "
"vector"
msgstr ""
